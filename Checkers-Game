public class CheckersGame {
private long[] pieces; // Index 0: Player 1 normal, 1: Player 1 kings, 2: Player 2 normal, 3: Player 2 kings
private boolean isPlayer1Turn;

public CheckersGame() {
pieces = new long[4]; // Array for pieces and kings for both players
initializeBoard();
isPlayer1Turn = true;
}

private void initializeBoard() {
pieces[0] = 0xFFF; // Player 1 normal pieces
pieces[1] = 0L; // Player 1 kings
pieces[2] = 0xFFF0000000000L; // Player 2 normal pieces
pieces[3] = 0L; // Player 2 kings
}

public void displayBoard() {
System.out.println("Player 1: normal pieces = P, kings = K");
System.out.println("Player 2: normal pieces = p, kings = k");
System.out.println(" 0 1 2 3 4 5 6 7");

for (int row = 0; row < 8; row++) {
System.out.print(row + " ");
for (int col = 0; col < 8; col++) {
int position = row * 8 + col;
long mask = 1L << position;

if ((pieces[0] & mask) != 0) {
System.out.print("P ");
} else if ((pieces[1] & mask) != 0) {
System.out.print("K ");
} else if ((pieces[2] & mask) != 0) {
System.out.print("p ");
} else if ((pieces[3] & mask) != 0) {
System.out.print("k ");
} else {
System.out.print(". ");
}
}
System.out.println();
}
}

public boolean move(int startRow, int startCol, int endRow, int endCol) {
int startPos = startRow * 8 + startCol;
int endPos = endRow * 8 + endCol;

long startMask = 1L << startPos;
long endMask = 1L << endPos;

// Validate move
if (!isMoveValid(startRow, startCol, endRow, endCol)) {
System.out.println("Invalid move");
return false;
}

int currentPlayerIndex = isPlayer1Turn ? 0 : 2;
int kingIndex = currentPlayerIndex + 1;

// Handle piece movement
if ((pieces[currentPlayerIndex] & startMask) != 0) {
pieces[currentPlayerIndex] &= ~startMask; // Remove from start
pieces[currentPlayerIndex] |= endMask; // Place at end
} else if ((pieces[kingIndex] & startMask) != 0) {
pieces[kingIndex] &= ~startMask;
pieces[kingIndex] |= endMask;
}

// Handle capturing
if (Math.abs(startRow - endRow) == 2) {
handleCapture(startRow, startCol, endRow, endCol);
}

// Handle promotion to king
if (isPlayer1Turn && endRow == 7) {
promoteToKing(0, 1, endMask);
} else if (!isPlayer1Turn && endRow == 0) {
promoteToKing(2, 3, endMask);
}

isPlayer1Turn = !isPlayer1Turn;
return true;
}

private void handleCapture(int startRow, int startCol, int endRow, int endCol) {
int captureRow = (startRow + endRow) / 2;
int captureCol = (startCol + endCol) / 2;
int capturePos = captureRow * 8 + captureCol;
long captureMask = 1L << capturePos;

int opponentPiecesIndex = isPlayer1Turn ? 2 : 0;
int opponentKingsIndex = opponentPiecesIndex + 1;

// Remove captured piece
pieces[opponentPiecesIndex] &= ~captureMask;
pieces[opponentKingsIndex] &= ~captureMask;
}

private void promoteToKing(int normalIndex, int kingIndex, long endMask) {
pieces[normalIndex] &= ~endMask; // Remove from normal pieces
pieces[kingIndex] |= endMask; // Promote to king
}

private boolean isMoveValid(int startRow, int startCol, int endRow, int endCol) {
int startPos = startRow * 8 + startCol;
long startMask = 1L << startPos;

int currentPlayerIndex = isPlayer1Turn ? 0 : 2;
int opponentIndex = isPlayer1Turn ? 2 : 0;

// Check if correct player's piece is moved
if ((pieces[currentPlayerIndex] & startMask) == 0 && (pieces[currentPlayerIndex + 1] & startMask) == 0) {
return false;
}

int endPos = endRow * 8 + endCol;
long endMask = 1L << endPos;

// Check if destination is empty
for (long piece : pieces) {
if ((piece & endMask) != 0) {
return false;
}
}

// Movement for normal pieces (only diagonal and forward)
if (isPlayer1Turn && endRow - startRow == 1 && Math.abs(endCol - startCol) == 1) {
return true;
} else if (!isPlayer1Turn && startRow - endRow == 1 && Math.abs(startCol - endCol) == 1) {
return true;
}

// Capture validation
if (Math.abs(startRow - endRow) == 2 && Math.abs(startCol - endCol) == 2) {
return isCaptureValid(startRow, startCol, endRow, endCol);
}

return false;
}

private boolean isCaptureValid(int startRow, int startCol, int endRow, int endCol) {
int captureRow = (startRow + endRow) / 2;
int captureCol = (startCol + endCol) / 2;
int capturePos = captureRow * 8 + captureCol;
long captureMask = 1L << capturePos;

int opponentPiecesIndex = isPlayer1Turn ? 2 : 0;
int opponentKingsIndex = opponentPiecesIndex + 1;

return (pieces[opponentPiecesIndex] & captureMask) != 0 || (pieces[opponentKingsIndex] & captureMask) != 0;
}

public boolean isGameOver() {
return (pieces[0] | pieces[1]) == 0 || (pieces[2] | pieces[3]) == 0;
}

public static void main(String[] args) {
CheckersGame game = new CheckersGame();
Scanner scanner = new Scanner(System.in);

while (!game.isGameOver()) {
game.displayBoard();
System.out.println("Enter move (startRow startCol endRow endCol): ");
int startRow = scanner.nextInt();
int startCol = scanner.nextInt();
int endRow = scanner.nextInt();
int endCol = scanner.nextInt();

if (game.move(startRow, startCol, endRow, endCol)) {
System.out.println("Move successful!");
} else {
System.out.println("Invalid move, try again.");
}
}

System.out.println("Game Over!");
}
}
